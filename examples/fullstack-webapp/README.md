# Fullstack Web Application Example

A complete fullstack web application demonstrating how to use PPM to manage dependencies across JavaScript (React frontend) and Python (Flask backend) in a single project.

## Features

- **Frontend**: React with TypeScript, modern build pipeline
- **Backend**: Flask API with SQLAlchemy database integration  
- **Development**: Hot reload, testing, linting across both ecosystems
- **Production**: Optimized builds, deployment scripts

## Project Structure

```
fullstack-webapp/
├── frontend/           # React TypeScript frontend
│   ├── src/
│   ├── public/
│   └── package.json    # Generated by PPM
├── backend/           # Flask Python backend
│   ├── app/
│   ├── migrations/
│   └── requirements.txt # Generated by PPM
├── shared/            # Shared utilities and types
├── project.toml       # PPM configuration
└── README.md
```

## Getting Started

### 1. Initialize and Install

```bash
# Clone or create the project
cd fullstack-webapp

# Install all dependencies (JavaScript + Python)
ppm install --dev
```

This will:
- Install React, TypeScript, and build tools to `node_modules/`
- Create Python virtual environment in `.venv/`
- Install Flask, SQLAlchemy, and dev tools to the virtual environment

### 2. Database Setup

```bash
# Initialize database
ppm run db:migrate

# Seed with sample data (optional)
ppm run db:seed
```

### 3. Development

Start both frontend and backend in development mode:

```bash
# Start both frontend and backend
ppm run dev

# Or start individually:
ppm run frontend:dev    # Frontend only (port 3000)
ppm run backend:dev     # Backend only (port 5000)
```

Visit `http://localhost:3000` to see the application.

### 4. Testing

```bash
# Run all tests (frontend + backend)
ppm run test

# Run tests for specific parts
ppm run frontend:test
ppm run backend:test

# Run tests with coverage
ppm run test:coverage
```

### 5. Production Build

```bash
# Build for production
ppm run build

# Start production server
ppm run start
```

## Available Scripts

All scripts are defined in `project.toml` and can be run with `ppm run <script>`:

| Script | Description |
|--------|-------------|
| `dev` | Start frontend and backend in development mode |
| `frontend:dev` | Start frontend development server |
| `backend:dev` | Start backend development server |
| `build` | Build frontend and prepare backend for production |
| `start` | Start production server |
| `test` | Run all tests |
| `frontend:test` | Run frontend tests |
| `backend:test` | Run backend tests |
| `test:coverage` | Run tests with coverage reports |
| `lint` | Lint frontend and backend code |
| `format` | Format code (Prettier + Black) |
| `db:migrate` | Run database migrations |
| `db:seed` | Seed database with sample data |

## Dependencies

### Frontend (JavaScript/TypeScript)
- **React** - UI framework
- **TypeScript** - Type safety
- **Vite** - Build tool and dev server
- **React Router** - Client-side routing
- **Axios** - HTTP client for API calls
- **@types/*** - TypeScript definitions

### Backend (Python)
- **Flask** - Web framework
- **SQLAlchemy** - Database ORM
- **Flask-CORS** - Cross-origin resource sharing
- **Flask-Migrate** - Database migrations
- **python-dotenv** - Environment variable management

### Development Tools
- **Jest** - JavaScript testing
- **pytest** - Python testing
- **ESLint** - JavaScript linting
- **Black** - Python code formatting
- **Prettier** - JavaScript/TypeScript formatting

## API Endpoints

The backend provides these API endpoints:

- `GET /api/users` - List all users
- `POST /api/users` - Create new user
- `GET /api/users/:id` - Get specific user
- `PUT /api/users/:id` - Update user
- `DELETE /api/users/:id` - Delete user

## Environment Variables

Create a `.env` file in the project root:

```env
# Database
DATABASE_URL=sqlite:///./app.db

# Flask
FLASK_ENV=development
FLASK_DEBUG=true
SECRET_KEY=your-secret-key-here

# CORS
FRONTEND_URL=http://localhost:3000
```

## Deployment

### Docker

```bash
# Build Docker image
docker build -t fullstack-webapp .

# Run container
docker run -p 8080:8080 fullstack-webapp
```

### Traditional Deployment

```bash
# Build frontend
ppm run build

# Install production dependencies only
ppm install --production

# Start production server
ppm run start
```

## Learning Points

This example demonstrates:

1. **Unified Dependencies**: Managing both npm and PyPI packages in one file
2. **Environment Isolation**: Python virtual environment + Node.js modules
3. **Script Coordination**: Running complex workflows across ecosystems
4. **Development Workflow**: Hot reload for both frontend and backend
5. **Testing Strategy**: Coordinated testing across languages
6. **Production Builds**: Optimized builds and deployment
